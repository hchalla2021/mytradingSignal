/**\n * ðŸ”¥ PRODUCTION useMarketSocket Hook\n * Handles real Zerodha WebSocket issues:\n * - Silent connections (connected but no ticks)\n * - Market timing awareness  \n * - Auto-recovery and status validation\n * - Proper tick validation\n */\n\n'use client';\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { getEnvironmentConfig } from '@/lib/env-detection';\n\n// Production-safe logging\nconst isDev = process.env.NODE_ENV === 'development';\nconst log = {\n  debug: (...args: unknown[]) => isDev && console.log(...args),\n  warn: (...args: unknown[]) => isDev && console.warn(...args),\n  error: console.error,\n};\n\nexport interface MarketTick {\n  symbol: string;\n  price: number;\n  change: number;\n  changePercent: number;\n  high: number;\n  low: number;\n  open: number;\n  close: number;\n  volume: number;\n  oi: number;\n  timestamp: string;\n  status: 'LIVE' | 'PRE_OPEN' | 'CLOSED' | 'OFFLINE';\n  analysis?: any;\n}\n\nexport interface MarketData {\n  NIFTY: MarketTick | null;\n  BANKNIFTY: MarketTick | null;\n  SENSEX: MarketTick | null;\n}\n\n// WebSocket statuses from production backend\nexport type WebSocketStatus = \n  | 'OFFLINE'        // Initial state\n  | 'WAITING'        // Waiting for market start (9:14:50)\n  | 'CONNECTING'     // Connecting to Zerodha\n  | 'CONNECTED'      // WebSocket connected\n  | 'SUBSCRIBED'     // Instruments subscribed\n  | 'LIVE'          // Receiving live ticks âœ…\n  | 'RECONNECTING'   // Auto-reconnecting\n  | 'STALE'         // Connected but no ticks (Zerodha silent connection)\n  | 'NO_TICKS'      // Market open but no data\n  | 'ERROR'         // Connection/auth error\n  | 'FAILED'        // Max retries exceeded\n  | 'DISCONNECTED'; // Manually disconnected\n\ninterface WebSocketMessage {\n  type: 'tick' | 'snapshot' | 'status' | 'heartbeat';\n  data?: MarketTick | Record<string, MarketTick>;\n  status?: WebSocketStatus;\n  message?: string;\n  timestamp?: string;\n}\n\n// Auto-detect WebSocket URL\nconst getWebSocketURL = (): string => {\n  const config = getEnvironmentConfig();\n  log.debug(`ðŸ”— WebSocket URL: ${config.wsUrl} (${config.displayName})`);\n  return config.wsUrl;\n};\n\nconst STORAGE_KEY = 'productionMarketData';\nconst TICK_TIMEOUT = 35000; // 35 seconds - if no tick, mark as stale\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Save/load cached data\nfunction saveMarketData(data: MarketData): void {\n  if (typeof window === 'undefined') return;\n  try {\n    const cached = {\n      data,\n      timestamp: Date.now(),\n    };\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(cached));\n  } catch (e) {\n    log.error('Failed to save market data:', e);\n  }\n}\n\nfunction loadMarketData(): MarketData | null {\n  if (typeof window === 'undefined') return null;\n  try {\n    const saved = localStorage.getItem(STORAGE_KEY);\n    if (saved) {\n      const parsed = JSON.parse(saved);\n      const age = Date.now() - (parsed.timestamp || 0);\n      \n      // Use cached data if less than 5 minutes old\n      if (age < 5 * 60 * 1000) {\n        return parsed.data;\n      }\n    }\n  } catch (e) {\n    log.error('Failed to load cached market data:', e);\n  }\n  return null;\n}\n\nexport function useProductionMarketSocket() {\n  // State management\n  const [marketData, setMarketData] = useState<MarketData>({\n    NIFTY: null,\n    BANKNIFTY: null,\n    SENSEX: null,\n  });\n  \n  const [connectionStatus, setConnectionStatus] = useState<WebSocketStatus>('OFFLINE');\n  const [statusMessage, setStatusMessage] = useState('');\n  const [lastTickTime, setLastTickTime] = useState<number | null>(null);\n  const [tickCount, setTickCount] = useState(0);\n  \n  // Refs\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const staleCheckIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const mountedRef = useRef(true);\n\n  // Computed states\n  const isConnected = ['CONNECTED', 'SUBSCRIBED', 'LIVE'].includes(connectionStatus);\n  const isReceivingData = connectionStatus === 'LIVE';\n  const hasStaleConnection = ['STALE', 'NO_TICKS'].includes(connectionStatus);\n  \n  // ðŸ”¥ KEY: This is the real connection quality indicator\n  const connectionQuality = (() => {\n    if (connectionStatus === 'LIVE') return 'excellent';\n    if (isConnected && !hasStaleConnection) return 'good';\n    if (connectionStatus === 'CONNECTING' || connectionStatus === 'RECONNECTING') return 'connecting';\n    if (hasStaleConnection) return 'poor';\n    return 'offline';\n  })();\n\n  const updateStatus = useCallback((status: WebSocketStatus, message: string = '') => {\n    if (!mountedRef.current) return;\n    \n    setConnectionStatus(status);\n    setStatusMessage(message);\n    \n    log.debug(`ðŸ“¡ Status: ${status} - ${message}`);\n  }, []);\n\n  const connect = useCallback(() => {\n    if (typeof window === 'undefined') return;\n    \n    // Prevent multiple connections\n    if (wsRef.current?.readyState === WebSocket.OPEN || \n        wsRef.current?.readyState === WebSocket.CONNECTING) {\n      return;\n    }\n\n    updateStatus('CONNECTING', 'Connecting to trading server...');\n    \n    try {\n      const wsUrl = getWebSocketURL();\n      if (!wsUrl) {\n        updateStatus('ERROR', 'WebSocket URL not configured');\n        return;\n      }\n      \n      const ws = new WebSocket(wsUrl);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        log.debug('ðŸ”— WebSocket connected');\n        updateStatus('CONNECTED', 'Connected to server');\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const message: WebSocketMessage = JSON.parse(event.data);\n          \n          switch (message.type) {\n            case 'tick':\n              if (message.data && 'symbol' in message.data) {\n                const tick = message.data as MarketTick;\n                \n                // Update last tick time\n                setLastTickTime(Date.now());\n                setTickCount(prev => prev + 1);\n                \n                // Update to LIVE status after first tick\n                if (connectionStatus !== 'LIVE') {\n                  updateStatus('LIVE', `Receiving live data from ${tick.symbol}`);\n                }\n                \n                // Update market data\n                setMarketData(prev => {\n                  const updated = {\n                    ...prev,\n                    [tick.symbol]: { ...tick }\n                  };\n                  saveMarketData(updated);\n                  return updated;\n                });\n                \n                log.debug(`ðŸ“ˆ Tick: ${tick.symbol} = â‚¹${tick.price}`);\n              }\n              break;\n\n            case 'snapshot':\n              if (message.data) {\n                log.debug('ðŸ“Š Snapshot received');\n                const snapshot = message.data as Record<string, MarketTick>;\n                \n                setMarketData({\n                  NIFTY: snapshot.NIFTY ? { ...snapshot.NIFTY } : null,\n                  BANKNIFTY: snapshot.BANKNIFTY ? { ...snapshot.BANKNIFTY } : null,\n                  SENSEX: snapshot.SENSEX ? { ...snapshot.SENSEX } : null,\n                });\n                \n                if (Object.keys(snapshot).length > 0) {\n                  setLastTickTime(Date.now());\n                }\n              }\n              break;\n\n            case 'status':\n              if (message.status) {\n                updateStatus(message.status, message.message || '');\n              }\n              break;\n\n            case 'heartbeat':\n              // Server is alive\n              break;\n          }\n        } catch (error) {\n          log.error('Failed to parse WebSocket message:', error);\n        }\n      };\n\n      ws.onclose = (event) => {\n        log.warn(`ðŸ”Œ WebSocket closed: ${event.code}`);\n        \n        // Auto-reconnect unless it was a clean close\n        if (event.code !== 1000 && mountedRef.current) {\n          updateStatus('RECONNECTING', 'Connection lost, reconnecting...');\n          \n          if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n          }\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            if (mountedRef.current) {\n              connect();\n            }\n          }, RECONNECT_DELAY);\n        } else {\n          updateStatus('DISCONNECTED', 'Disconnected');\n        }\n      };\n\n      ws.onerror = () => {\n        log.error('âŒ WebSocket error');\n        updateStatus('ERROR', 'Connection error');\n      };\n\n    } catch (error) {\n      log.error('Failed to create WebSocket:', error);\n      updateStatus('ERROR', 'Failed to create connection');\n    }\n  }, [connectionStatus, updateStatus]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (wsRef.current) {\n      wsRef.current.close(1000); // Clean close\n      wsRef.current = null;\n    }\n    updateStatus('DISCONNECTED', 'Manually disconnected');\n  }, [updateStatus]);\n\n  const forceReconnect = useCallback(() => {\n    log.debug('ðŸ”„ Force reconnecting...');\n    disconnect();\n    setTimeout(connect, 1000);\n  }, [connect, disconnect]);\n\n  // Check for stale connections\n  useEffect(() => {\n    if (staleCheckIntervalRef.current) {\n      clearInterval(staleCheckIntervalRef.current);\n    }\n    \n    staleCheckIntervalRef.current = setInterval(() => {\n      if (!mountedRef.current) return;\n      \n      // Only check if we think we're connected\n      if (isConnected && lastTickTime) {\n        const timeSinceLastTick = Date.now() - lastTickTime;\n        \n        // If no tick for 35 seconds during market hours, mark as stale\n        if (timeSinceLastTick > TICK_TIMEOUT) {\n          const minutes = Math.floor(timeSinceLastTick / 60000);\n          updateStatus('STALE', `No data for ${minutes}m - Zerodha silent connection`);\n        }\n      }\n    }, 10000); // Check every 10 seconds\n    \n    return () => {\n      if (staleCheckIntervalRef.current) {\n        clearInterval(staleCheckIntervalRef.current);\n      }\n    };\n  }, [isConnected, lastTickTime, updateStatus]);\n\n  // Initialize on mount\n  useEffect(() => {\n    mountedRef.current = true;\n    \n    // Load cached data immediately\n    const cached = loadMarketData();\n    if (cached) {\n      setMarketData(cached);\n      log.debug('ðŸ’¾ Loaded cached market data');\n    }\n    \n    // Connect to WebSocket\n    connect();\n    \n    return () => {\n      mountedRef.current = false;\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  return {\n    // Data\n    marketData,\n    \n    // Connection state\n    connectionStatus,\n    statusMessage,\n    isConnected,\n    isReceivingData,\n    connectionQuality,\n    \n    // Statistics\n    lastTickTime,\n    tickCount,\n    \n    // Actions\n    reconnect: forceReconnect,\n    disconnect,\n    \n    // Status helpers\n    isStale: hasStaleConnection,\n    isLive: connectionStatus === 'LIVE',\n    isWaiting: connectionStatus === 'WAITING',\n    hasError: connectionStatus === 'ERROR' || connectionStatus === 'FAILED',\n  };\n}\n\n// Export the enhanced hook as default\nexport { useProductionMarketSocket as useMarketSocket };